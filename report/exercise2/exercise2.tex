\section{Heat equation in one dimension}
\label{heat-equation}
In this section, we consider the one-dimensional heat equation for $u = u(x, t)$, 
\begin{equation*}
    u_t = u_{xx}, \quad u(x, 0) = f(x), \quad x \in [0,1] := \Omega, 
    \label{eq:heat-eq}
\end{equation*}
with either Neumann or Dirchlet boundary conditions, 
and solve it numerically using both the Backward Euler method and Crank-Nicolson method. 
These are $\mathcal{O}(k+h^2)$ and $\mathcal{O}(k^2+h^2)$ methods respectively, 
and we will analyze and compare their convergence using mesh refinement as we did in section \ref{task_1}. However we will here restrict our attention to uniform grids only. 

\subsection{Numerical solution method}
To solve the heat equation numerically we first perform semi-discretization, 
i.e. we do spatial discretization and keep the time continous. 
As in section \ref{task_1}, 
we divide the interval $\Omega$ into $M+2$ equidistant nodes with separation $h=1/(M+1)$, 
so that we get a uniform grid with $M$ internal nodes and two boundary nodes. 
We then express the spatial derivative using the central finite difference to get 
\begin{equation*}
    u_t(x_m, t) = \frac{1}{h^2} \delta_x^2 u(x_m, t) + \mathcal{O}(h^2), 
    \quad m = 0,...,M+1.
\end{equation*}
We now introduce the single variate functions $v_m(t)$ as the approximation to $u(x_m, t)$, 
at each node $x_m$, 
turning the PDE into a set of ODEs 
\begin{equation*}
    \frac{dv_m(t)}{dt} = \frac{1}{h^2} \delta_x^2 v_m(t), 
    \quad v_m(0) = f(x_m). 
\end{equation*}

The problem is then generally solved by imposing the boundary conditions, 
and numerically integrating the equations in time. 
The integration can be done by using one of the many off-shelf routines for ODEs, 
e.g. Euler's method,  
and for convenience we employ the $\theta$-method, 
which for general ODEs $y' = g(y, t)$ is given as
\begin{equation*}
    y^{n+1} = y^n + \Delta t ((1-\theta)g(y^n, t_n)+\theta g(y^{n+1}, t_{n+1})). 
\end{equation*}
Using a constant time step $\Delta t = k$ leads to uniform discretization of the time interval, 
which we divide into $N$ equidistant points, 
and the final discrete grid for space and time is illustrated in figure \ref{fig:2-uniform-grid}.
This gives the approximate solution of $v_m(t)$ at $N$ finite times $t_n = nk, 
\: n = 0, \ldots N-1, 
\: k = 1/(N-1)$, 
and we denote the fully discretized approximation of $u(x_m, t_n)$ as $U_{m}^{n}$. 
After organizing the terms, 
the $\theta$-method for the 1D heat equation is then written out as
\begin{equation}
    (1 - \theta r \delta_x^2)U_m^{n+1} = (1 + (1-\theta)r\delta_x^2)U_m^n, 
    \label{eq:theta-heat}
\end{equation}
where we have defined $r=k/h^2$. 
Setting the value of $\theta$ in \eqref{eq:theta-heat} determines the specific numerical scheme. 
We have
\begin{equation*}
\begin{split}
    \text{Forward Euler} \quad \theta = 0 \\
    \text{Backward Euler} \quad \theta = 1 \\
    \text{Crank-Nicolson} \quad \theta = \frac{1}{2}, \\
\end{split}
\end{equation*}
and we will as mentioned consider the Bacward-Euler and Crank-Nicolson methods. 

\begin{figure}[ht]
    \centering
    \input{exercise2/grid_figure.pgf}
    \caption{Discrete uniform grid}
    \label{fig:2-uniform-grid}
\end{figure}

\subsubsection{Boundary conditions}
For Dirchlet boundary conditions $u(0, t) = \sigma, \: u(1, t) = \beta$, 
we substitute $U_0^{n+1} = \sigma$ and $U_M^{n+1} = \beta$ in \eqref{eq:theta-heat} for $m=0$ and $m=M+1$. 
In matrix form, 
the equation for the remaining inner nodes is then written as
\begin{multline}
    \begin{bmatrix}
    1+2\theta r & -\theta r \\
    -\theta r & 1+2\theta r & -\theta r & \\
      & \ddots & \ddots & \ddots & \\
      &   & -\theta r & 1+2\theta r & -\theta r \\
      &   &  & -\theta r & 1+2\theta r \\
    \end{bmatrix}
    \begin{bmatrix}
    U_{1}^{n+1} \\ U_{2}^{n+1} \\ \vdots \\ U_{M-1}^{n+1} \\ U_{M}^{n+1} \\
    \end{bmatrix}
    \\
    = 
    \begin{bmatrix}
    1-2r(1 - \theta) & r(1-\theta) \\
    r(1-\theta) & 1-2r(1 - \theta) & r(1-\theta) & \\
      & \ddots & \ddots & \ddots & \\
      &   & r(1-\theta) & 1-2r(1 - \theta) & r(1-\theta) \\
      &   &  & r(1-\theta) & 1-2r(1 - \theta) \\
    \end{bmatrix}
    \begin{bmatrix}
    U_{1}^{n} \\ U_{2}^{n} \\ \vdots \\ U_{M-1}^{n} \\ U_{M}^{n}
    \end{bmatrix}
    + 
    \begin{bmatrix}
    \theta r \sigma \\ 0 \\ \vdots \\ 0 \\ \theta r \beta
    \end{bmatrix}
    .
    \label{eq:theta-heat-matrix-dirchlet}
\end{multline}

For Neumann boundary conditions, $u_x(0, t) = \sigma, \: u_x(1, t) = \beta$, 
we introduce fictitious nodes to the left and right of the spatial grid, 
and approximate the first derivatives at the boundaries by
\begin{equation*}
    \frac{U_1 - U_{-1}}{2h} = \sigma
    \quad and \quad
    \frac{U_{M+2} - U_{M}}{2h} = \beta. 
\end{equation*}
Inserting this into \eqref{eq:theta-heat} for $m=0$ and $m=M+1$, 
and eliminating the fictitious nodes we get 
\begin{equation*}
\begin{split}
    (1+r\theta)U_0^{n+1} - r\theta U_1^{n+1} = (1-2r(1-\theta))U_0^n + r(1-\theta)U_1^n - 2hr\sigma
    \quad (for \: m=0) \\
    (1+r\theta)U_{M+1}^{n+1} - r\theta U_M^{n+1} = (1-2r(1-\theta))U_{M+1}^n + r(1-\theta)U_M^n - 2hr\beta
    \quad (for \: m=M+1), 
\end{split}
\end{equation*}
which we combine with \eqref{eq:theta-heat} for the inner nodes, $1 \leq m \leq M$, 
to get the equation as a $(M+2)\times (M+2)$ linear system
\begin{multline}
    \begin{bmatrix}
    1+\theta r & -\theta r \\
    -\theta r & 1+2\theta r & -\theta r & \\
      & \ddots & \ddots & \ddots & \\
      &   & -\theta r & 1+2\theta r & -\theta r \\
      &   &  & -\theta r & 1+\theta r \\
    \end{bmatrix}
    \begin{bmatrix}
    U_{0}^{n+1} \\ U_{1}^{n+1} \\ \vdots \\ U_{M}^{n+1} \\ U_{M+1}^{n+1} \\
    \end{bmatrix}
    \\
    = 
    \begin{bmatrix}
    1-2r(1 - \theta) & r(1-\theta) \\
    r(1-\theta) & 1-2r(1 - \theta) & r(1-\theta) & \\
      & \ddots & \ddots & \ddots & \\
      &   & r(1-\theta) & 1-2r(1 - \theta) & r(1-\theta) \\
      &   &  & r(1-\theta) & 1-2r(1 - \theta) \\
    \end{bmatrix}
    \begin{bmatrix}
    U_{0}^{n} \\ U_{1}^{n} \\ \vdots \\ U_{M}^{n} \\ U_{M+1}^{n}
    \end{bmatrix}
    + 
    \begin{bmatrix}
    -2hr\sigma \\ 0 \\ \vdots \\ 0 \\ -2hr\beta
    \end{bmatrix}
    .
    \label{eq:theta-heat-matrix-neumann}
\end{multline}
All quantities on the right hand sides in \eqref{eq:theta-heat-matrix-dirchlet} and \eqref{eq:theta-heat-matrix-neumann} are known, 
i.e. the equations are on the form $A\vec{x}=\vec{b}$, 
and the known $\vec{b}$ is just written via a matrix-vector product for notational convenience. 
The system of equation is then solved at each time step using "scipy.sparse.linalg.spsolve", 
and the left hand side matrix is stored as a compressed sparse row/column % Må finne ut hvilken som er lur(est). 
matrix. 

With the numerical schemes in hand we now solve the heat equation with the following Neumann boundary conditions and initial condition, 
\begin{equation}
    u_x(0,t) = u_x(1,t) = 0, \quad u(x,0) = 2\pi x - \sin(2\pi x). 
    \label{eq:2a}
\end{equation}
The computed solutions for $t \in [0, 0.5]$ is plotted in figure \ref{fig:2a-surface}, 
and qualitatively the solution behaves in accordance to what one should expect for the heat equation. 
To quantify and compare the accuracy of the numerical schemes we will now proceed to analyze convergence using mesh refinement, 
similar to what we did in section \ref{task_1}. 

\begin{figure}[ht]
    \centering
    \input{exercise2/2a_surface_plot.pgf}
    \caption{I am a surface plot, Hooray :)}
    \label{fig:2a-surface}
\end{figure}

\subsection{Convergence and mesh refinement}
As in section \ref{task_1} we now analyze the convergence of the numerical solution methods, 
by doing mesh refinement of the spatial grid $x_m$. 
For \eqref{eq:2a}, the the analytical solution is not available in closed form, 
so in order to analyze convergence we compute a reference solution using a sufficiently high $M$, 
which we use in place of the analytical solution when computing the error. 

In order to analyze the convergence further, 
we also consider the heat equation with a set of boundary and initial conditions for which the analytical solution is known. 
Specifically we consider 
\begin{equation}
    u(0,t) = u(1,t) = 0, \quad u(x,0) = \sin(\pi x), 
    \label{eq:2b-manufactured}
\end{equation}
on the same domain $x \in [0,1] := \Omega$ and $t > 0$. 
Note that we now have Dirchlet boundary conditions, 
and the analytical solution is readily available as 
\footnote{The analytical solution can be computed using e.g. separation of variables.}
\begin{equation}
    u(x,t) = \sin(\pi x)  e^{- \pi^2 t}.
    % Necessary to derive this? Just separation of variables,
    % and it is like the most basic example of the heat equation, 
    % probably included in any introductory text on PDEs
\end{equation}

When doing mesh refinement of the spatial grid, 
we vary the number of spatial grid points $M$, 
and compute the numerical solution at the same point in time $t=t_{end}$. 
We keep the number of time steps $N$ fixed, 
so that the error from the time discretization does not vary, 
and compute the $L_2$ discrete relative error with respect to the reference solution. 
For equation \eqref{eq:2b-manufactured} we also compute the $l_2$ continous relative error, 
and compute errors with respect to the analytical solution. 
The resulting convergence plots are shown in figure \ref{fig:2a-convergence} and \ref{fig:2b-convergence}. 

Both methods are second order in the spatial step $h$, 
and are unconditionally stable, 
unlike e.g. the explicit Forward Euler method ($\theta=0$). 
Despite this, 
the solution with the Neumann boundary conditions \ref{eq:2a} seems to break down for sufficiently low $M$ using Backward Euler, 
and the error blows up as seen in figure \ref{fig:2a-convergence}. 
\textbf{Comment from KA: I dont really know why.}

Crank-Nicolson is however one order higher in the time step $k$, 
so that the total error is lower for Crank-Nicolson than Backward-Euler when $M$ and $N$ are the same. 
This is seen when refining the spatial step $h$; 
at large $h$ (low $M$), 
the error is dominated by the spatial error, 
and as we decrease $h$ (increase $M$) we should see the expected second order convergence in the spatial step. 
At some point, 
when the spatial error has become sufficiently small, 
the total error will be dominated by the error in the time step $k$, 
and we expect this to happen earlier for the Backward-Euler method. 
In figure \ref{fig:2b-convergence} we see exactly this. 
The error of the Crank-Nicolson solution with $N=10000$ exhibits second order convergence throughout the entire refinement, 
but when lowering the number of time steps to $N=1000$, 
the time step error starts to dominate towards the end of the refinement and the error curve flattens. 
For the solution computed with the Backward-Euler method we see the flattening happening much earlier, 
which is due to this method being less accurate in time. 

\begin{figure}[ht]
    \centering
    \input{exercise2/2a_UMR_discrete.pgf}
    \caption{Convergence plot, h refinement (2a)}
    \label{fig:2a-convergence}
\end{figure}

\begin{figure}[ht]
    \centering
    \input{exercise2/2b_UMR_combined.pgf}
    \caption{Convergence plot, h refinement (2b)}
    \label{fig:2b-convergence}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: AMR data is likely to change.
% Luckily, that isn't a big problem, as pgfplots is brilliant.

% Seriously. It's glorious.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%        ,,,,,             pgfplots
%       ////""\               .
%      (((/ m m              -|-                        __
%      )))c  = )              |                        (__)
%     ////-./~`    .                                    []
%    (((( `.`\    ::                                    []
%     )))`\ \)).-;.'                           .------, []
%      (() `._.-'`                           _(        )[]
%      )/ `. |  .'`^^^^^^^^^^^^^^^^^^^^^^^^^^))\`.----'`[]
%jgs   (    \' { ~ - ~~ _  ~  -  ~~  - ~  - ((  | |     []
%  .-.--\    \ {                             )) | |     []
%  |_;_._`\   |{                            ((__|_|-----[]
% |  ;   ```  ;{                             ))         []
% | /``-.____/ `~~~[]~~~~~~~~~~~~~~~~~~~~~~~'-'         []
% `'              (__)                                 (__)
%\begin{figure}[ht]
%    \centering
%    \input{exercise2/2b_AMR_combined.pgf}
%\end{figure}

\section{Invicid Burgers' equation}

In this section we turn to solve the inviscid Burgers' equation with given Dirchlet boundary conditions and initial condition
\begin{equation}
    u_t = -uu_x, \quad u(0, t) = u(1, t) = 0, \quad u(x, 0) = exp(-400(x-1/2)^2).
    \label{eq:burger}
\end{equation}
This equation exhibits breaking; 
after some point in time $t_b$ the solution breaks, 
and the unique solution does not exist, 
leading to the formation of a \textit{shock wave}.\cite{burgers} 
The time $t_b$ before this can happen is given by
\begin{equation}
% I am not sure if this is the exact time of breaking or just the earliest possible breaking time. 
    t_b = \frac{-1}{min f'(x)}, 
    \label{eq:t_break}
\end{equation}
where $f(x)$ is the given initial condition $u(x, 0) = f(x)$.\cite{burgers} 

\subsection*{Numerical solution method}
To solve \eqref{eq:burger} numerically we perform semidiscretization in the same way as we did for the heat equation in section \ref{heat-equation}, 
also on a uniform spatial grid as described in section \ref{task_1}. 
The resulting system of ODEs is
\begin{equation*}
    \frac{\partial v_m}{\partial t} = -v_m \frac{1}{2h} (v_{m+1} - v_{m-1}). 
\end{equation*}
We impose the Dirchlet boundary conditions and integrate the ODEs using \textit{solve\_ivp} from the SciPy library, 
with the default explicit Runge-Kutta method of order 4(5)\cite{solve_ivp}. \\
\textbf{Comment/question:} Is it fine to use scipy.integrate.solve\_ivp, 
or should it be all home cooking? 

\subsection{Time of breaking}
Insertion of $u(x, 0)$ for $f$ in \eqref{eq:t_break}, 
gives $t_b \approx 0.058$. 
To get a criterion for when the numerical solution has broken down, 
we use that the stable solution should be strictly increasing from $x=0$ to towards the apex, 
and then strictly decreasing from the apex towards the right boundary at $x=1$. 
When this is no longer the case we say that the solution has broken, 
and the time for which this happened for our solution was at $t^* \approx 0.055$. 
Figure \ref{fig:burgers-samples} shows the solution sampled around the time of breaking. 
% Not sure what to make of this result, also varying M seems to affect 
% the breaking time. I made a function wich calculates the :

\begin{figure}[ht]
    \centering
    \input{exercise2/2c_samples.pgf}
    \caption{Numerically computed solution to the Invicid Burgers' equation around the time of breaking.}
    \label{fig:burgers-samples}
\end{figure}
